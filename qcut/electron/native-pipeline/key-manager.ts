/**
 * API Key Manager
 *
 * Manages API keys via .env files for CLI usage.
 * Supports setup, get, set, and validation of API keys.
 *
 * @module electron/native-pipeline/key-manager
 */

import * as fs from "fs";
import * as path from "path";
import * as os from "os";

const KEY_NAMES = [
	"FAL_KEY",
	"GEMINI_API_KEY",
	"GOOGLE_AI_API_KEY",
	"OPENROUTER_API_KEY",
	"ELEVENLABS_API_KEY",
	"OPENAI_API_KEY",
	"RUNWAY_API_KEY",
	"HEYGEN_API_KEY",
	"DID_API_KEY",
	"SYNTHESIA_API_KEY",
] as const;

export type ApiKeyName = (typeof KEY_NAMES)[number];

export interface KeyStatus {
	name: string;
	configured: boolean;
	source: "env" | "envfile" | "aicp-cli" | "none";
	masked?: string;
}

function getEnvFilePath(configDirOverride?: string): string {
	if (configDirOverride) return path.join(configDirOverride, ".env");
	return path.join(os.homedir(), ".qcut", ".env");
}

function readEnvFile(configDirOverride?: string): Map<string, string> {
	const envPath = getEnvFilePath(configDirOverride);
	const entries = new Map<string, string>();

	if (!fs.existsSync(envPath)) return entries;

	const content = fs.readFileSync(envPath, "utf-8");
	for (const line of content.split("\n")) {
		const trimmed = line.trim();
		if (!trimmed || trimmed.startsWith("#")) continue;
		const eqIdx = trimmed.indexOf("=");
		if (eqIdx === -1) continue;
		const key = trimmed.slice(0, eqIdx).trim();
		let value = trimmed.slice(eqIdx + 1).trim();
		if (
			(value.startsWith('"') && value.endsWith('"')) ||
			(value.startsWith("'") && value.endsWith("'"))
		) {
			value = value.slice(1, -1);
		}
		entries.set(key, value);
	}

	return entries;
}

function writeEnvFile(entries: Map<string, string>): void {
	const envPath = getEnvFilePath();
	const dir = path.dirname(envPath);
	fs.mkdirSync(dir, { recursive: true });

	const lines: string[] = [
		"# QCut API Keys",
		"# Generated by qcut-pipeline setup",
		"",
	];
	for (const [key, value] of entries) {
		lines.push(`${key}=${value}`);
	}
	lines.push("");

	fs.writeFileSync(envPath, lines.join("\n"), { mode: 0o600 });
}

function maskKey(value: string): string {
	if (value.length <= 8) return "****";
	return value.slice(0, 4) + "****" + value.slice(-4);
}

export function setKey(name: string, value: string): void {
	const entries = readEnvFile();
	entries.set(name, value);
	writeEnvFile(entries);
}

export function deleteKey(name: string): boolean {
	const entries = readEnvFile();
	if (!entries.has(name)) return false;
	entries.delete(name);
	writeEnvFile(entries);
	return true;
}

export function isKnownKey(name: string): boolean {
	return (KEY_NAMES as readonly string[]).includes(name);
}

export { KEY_NAMES };

export function getKey(name: string): string | undefined {
	const envValue = process.env[name];
	if (envValue) return envValue;

	const entries = readEnvFile();
	return entries.get(name);
}

export function checkKeys(): KeyStatus[] {
	const envEntries = readEnvFile();

	// Also check AICP CLI credentials
	const aicpPath = getAicpCredentialsPath();
	const aicpEntries = new Map<string, string>();
	if (fs.existsSync(aicpPath)) {
		const content = fs.readFileSync(aicpPath, "utf-8");
		for (const line of content.split("\n")) {
			const trimmed = line.trim();
			if (!trimmed || trimmed.startsWith("#")) continue;
			const eqIdx = trimmed.indexOf("=");
			if (eqIdx === -1) continue;
			aicpEntries.set(trimmed.slice(0, eqIdx).trim(), trimmed.slice(eqIdx + 1).trim());
		}
	}

	return KEY_NAMES.map((name) => {
		const envValue = process.env[name];
		const fileValue = envEntries.get(name);
		const aicpValue = aicpEntries.get(name);

		if (envValue) {
			return {
				name,
				configured: true,
				source: "env" as const,
				masked: maskKey(envValue),
			};
		}
		if (fileValue) {
			return {
				name,
				configured: true,
				source: "envfile" as const,
				masked: maskKey(fileValue),
			};
		}
		if (aicpValue) {
			return {
				name,
				configured: true,
				source: "aicp-cli" as const,
				masked: maskKey(aicpValue),
			};
		}
		return { name, configured: false, source: "none" as const };
	});
}

export function setupEnvTemplate(): string {
	const envPath = getEnvFilePath();
	if (fs.existsSync(envPath)) {
		return envPath;
	}

	const entries = new Map<string, string>();
	for (const name of KEY_NAMES) {
		entries.set(name, "");
	}
	writeEnvFile(entries);
	return envPath;
}

function getAicpCredentialsPath(): string {
	if (process.platform === "win32") {
		return path.join(process.env.APPDATA || os.homedir(), "video-ai-studio", "credentials.env");
	}
	return path.join(os.homedir(), ".config", "video-ai-studio", "credentials.env");
}

export function loadEnvFile(configDirOverride?: string): void {
	const entries = readEnvFile(configDirOverride);
	for (const [key, value] of entries) {
		if (value && !process.env[key]) {
			process.env[key] = value;
		}
	}

	// Fallback: load from AICP CLI credentials if keys are still missing
	const aicpPath = getAicpCredentialsPath();
	if (fs.existsSync(aicpPath)) {
		const aicpEntries = new Map<string, string>();
		const content = fs.readFileSync(aicpPath, "utf-8");
		for (const line of content.split("\n")) {
			const trimmed = line.trim();
			if (!trimmed || trimmed.startsWith("#")) continue;
			const eqIdx = trimmed.indexOf("=");
			if (eqIdx === -1) continue;
			aicpEntries.set(trimmed.slice(0, eqIdx).trim(), trimmed.slice(eqIdx + 1).trim());
		}
		for (const [key, value] of aicpEntries) {
			if (value && !process.env[key]) {
				process.env[key] = value;
			}
		}
	}
}
