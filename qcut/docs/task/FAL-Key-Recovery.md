# FAL Key Recovery: How the Key Was Found

## The Problem

When trying to generate images with AICP's Nano Banana Pro model, the FAL API key could not be found through any of the standard 3-tier lookup methods.

### Tier 1: Environment Variable — Not Set

```bash
echo $FAL_KEY
# (empty)
```

No `FAL_KEY` was exported in the shell environment.

### Tier 2: QCut Electron Store — Encrypted

The key was saved via QCut's Settings UI, which stores it in:

```
~/Library/Application Support/qcut/api-keys.json
```

However, the values are **encrypted with Electron's `safeStorage`** module, making them unreadable from outside the Electron process:

```json
{
  "falApiKey": "djEwo97o0XWheNjPmR0wNMHbqtAuOfR+8zPO0qyRJc+vus7PH..."
}
```

### Tier 3: AICP CLI Credential Store — Empty

```
~/.config/video-ai-studio/credentials.env
```

This file existed but was empty (0 bytes). No keys had been set via `aicp set-key`.

### Why the AICP CLI Couldn't Help

The bundled AICP binary (v1.0.25) had **no text-to-image providers loaded** — `aicp list-models` showed "No models available (integration pending)" for the Text-To-Image category. Even if the key were available, the CLI couldn't generate images.

## The Solution

### Step 1: Understand Electron's safeStorage Encryption

Electron's `safeStorage` on macOS uses **Chromium's OSCrypt** mechanism:

1. A password is stored in the **macOS Keychain** under the app's service name
2. An AES-128-CBC key is **derived** from that password using PBKDF2
3. Data is encrypted and stored with a `v10` prefix

### Step 2: Retrieve the Keychain Password

```bash
security find-generic-password -s "qcut" -w
# Returns: QIb20cYx4gMZDsFaVYOHjQ==
```

This is the base password stored in the macOS Keychain by Electron for the "qcut" app.

### Step 3: Decrypt Using Chromium's OSCrypt Algorithm

The decryption follows Chromium's exact algorithm:

| Parameter | Value |
|-----------|-------|
| KDF | PBKDF2-HMAC-SHA1 |
| Salt | `saltysalt` (literal string) |
| Iterations | 1003 |
| Key length | 16 bytes (AES-128) |
| Cipher | AES-128-CBC |
| IV | 16 space characters (`0x20` x 16) |
| Data prefix | `v10` (3 bytes, stripped before decryption) |
| Padding | PKCS7 |

```python
import base64, hashlib
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding

# 1. Keychain password
keychain_pw = 'QIb20cYx4gMZDsFaVYOHjQ=='

# 2. Derive AES key
key = hashlib.pbkdf2_hmac(
    'sha1',
    keychain_pw.encode('utf-8'),
    b'saltysalt',
    1003,
    dklen=16
)

# 3. Read encrypted value, strip "v10" prefix
encrypted_raw = base64.b64decode(encrypted_b64)
encrypted_data = encrypted_raw[3:]  # skip "v10"

# 4. Decrypt AES-128-CBC with IV = 16 spaces
iv = b' ' * 16
cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
decryptor = cipher.decryptor()
decrypted = decryptor.update(encrypted_data) + decryptor.finalize()

# 5. Remove PKCS7 padding
unpadder = padding.PKCS7(128).unpadder()
result = unpadder.update(decrypted) + unpadder.finalize()
```

### Step 4: Use the FAL API Directly

With the decrypted key, images were generated by calling the FAL API directly with `curl` instead of going through the AICP CLI:

```bash
curl -s "https://fal.run/fal-ai/nano-banana-pro" \
  -H "Authorization: Key $FAL_KEY" \
  -H "Content-Type: application/json" \
  -d '{"prompt":"...","image_size":"landscape_16_9"}'
```

## Summary

| Step | What | Tool |
|------|------|------|
| 1 | Found encrypted key in `api-keys.json` | `cat` |
| 2 | Retrieved Keychain password | `security find-generic-password` |
| 3 | Decrypted with Chromium OSCrypt algorithm | Python + `cryptography` |
| 4 | Called FAL API directly | `curl` |

## Recommendation

To avoid this in the future, also set the key in the AICP CLI credential store so it's accessible without decryption:

```bash
aicp set-key FAL_KEY
```

Or export it in your shell profile (`~/.zshrc`):

```bash
export FAL_KEY="your-key-here"
```
